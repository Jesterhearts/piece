syntax = "proto3";

package effects;

import "color.proto";
import "comment.proto";
import "cost.proto";
import "counters.proto";
import "empty.proto";
import "mana.proto";
import "targets.proto";
import "types.proto";

message Effect {
  oneof effect {
    ApplyThen apply_then = 1 [
      (comment.comment) =
          "Apply an effect, then apply another effect, allowing another round of choosing targets. You need to use this if your effects depend on the results of previous effects. See Glowspore Shaman and Malcom, Alluring Scoundrel for examples. "
    ];
    ApplyThenIfWas apply_then_if_was = 2 [
      (comment.comment) =
          "Apply an effect, then examine the log of results from the effect and compare it to a list of restrictions. If any log entry resulting from the applied effects matches, apply another effect.This is used e.g.to apply an effect if the target that just left the battlefield was tapped."
    ];
    BattleCry battle_cry = 3 [
      (comment.comment) =
          "Implement the Battle Cry effect. You don't need to use this directly, specifying the Battle Cry keyword in the keyword list is enough."
    ];
    BattlefieldModifier battlefield_modifier = 4 [
      (comment.comment) =
          "Apply a modifier to the battlefield without targeting anything. Typically you will want to set the `entire_battlefield` flag to true for the modifier."
    ];
    CantAttackThisTurn cant_attack_this_turn = 5
        [(comment.comment) = "Prevent target player from attacking this turn."];
    Cascade cascade = 6 [
      (comment.comment) =
          "Implement the keyword Cascade. You probably don't want to use this - instead use the Cascade keyword in the keywords list."
    ];
    ChooseCast choose_cast = 7 [
      (comment.comment) =
          "Choose to cast a card from a list of cards narrowed by restrictions."
    ];
    ControllerDiscards controller_discards = 8 [
      (comment.comment) =
          "The controller of the card triggering the effect discards some number of cards unless they meet some restrictions."
    ];
    ControllerDrawsCards controller_draws_cards = 9 [
      (comment.comment) =
          "The controller of the card triggering the effect draws some number of cards."
    ];
    ControllerLosesLife controller_loses_life = 10 [
      (comment.comment) =
          "The controller of the card triggering the effect loses life unless they meet some restrictions."
    ];
    CopyOfAnyCreatureNonTargeting copy_of_any_creature_non_targeting = 11 [
      (comment.comment) =
          "Copy any creature on the battlefield without checking if it can be targetted (i.e. ignore hexproof and shroud). This is used to implement e.g. Clone."
    ];
    CopySpellOrAbility copy_spell_or_ability = 12
        [(comment.comment) = "Copy a spell or ability on the stack"];
    CounterSpellOrAbility counter_spell_or_ability = 13
        [(comment.comment) = "Counter a spell."];
    CounterSpellUnlessPay counter_spell_unless_pay = 14
        [(comment.comment) =
             "Counter spell unless the spell's controller pays some cost."];
    CreateToken create_token = 15 [(comment.comment) = "Create a token."];
    CreateTokenCopy create_token_copy = 16 [
      (comment.comment) =
          "Create a token copy of another permanent with some modifiers applied."
    ];
    Cycling cycling = 17 [
      (comment.comment) =
          "Implement the cycling keyword. If there are restrictions listed for the effect, it will act as a tutor for matching cards. If no restrictions are specified, it will default to drawing a card."
    ];
    DealDamage deal_damage = 18 [
      (comment.comment) =
          "Deal some amount of damage to any target, narrowed by restrictions."
    ];
    DestroyEach destroy_each = 19
        [(comment.comment) =
             "Destroy each permanent matching some set of restrictions."];
    DestroyTarget destroy_target = 20 [
      (comment.comment) =
          "Destroy a target permanent from a target list narrowed by restrictions."
    ];
    Discover discover = 21
        [(comment.comment) = "Implement the Discover keyword."];
    Equip equip = 22
        [(comment.comment) =
             "Apply modifiers to a target using the Equip mechanics."];
    ExamineTopCards examine_top_cards = 23 [
      (comment.comment) =
          "Examine the top N cards of the effect controller's library and give the player a choice of where to move the cards to. This is used to implement e.g. Confounding Riddle's effect."
    ];
    ExileTarget exile_target = 24
        [(comment.comment) =
             "Exile a target from a list narrowed by a set of restrictions."];
    ExileTargetCreatureManifestTopOfLibrary
        exile_target_creature_manifest_top_of_library = 25 [
          (comment.comment) =
              "TODO: This should probably be split into two separate effects. It is currently used to implement just Reality Shift."
        ];
    ExileTargetGraveyard exile_target_graveyard = 26
        [(comment.comment) = "Exile the graveyard of target player."];
    ForEachManaOfSource for_each_mana_of_source = 27 [
      (comment.comment) =
          "For each mana from a particular source (e.g. cave or treasure) spent on casting this effect's card, apply some effects."
    ];
    ForEachPlayerChooseThen for_each_player_choose_then = 28 [
      (comment.comment) =
          "Choose a permanent matching some list of restrictions for each player, then apply some effects."
    ];
    GainCounters gain_counters = 29 [
      (comment.comment) =
          "Place some number of counters on a the card triggering the effect."
    ];
    GainLife gain_life = 30
        [(comment.comment) = "The controller of this effect gains life."];
    IfThenElse if_then_else = 31 [
      (comment.comment) =
          "If the source of this effect passes some restrictions, apply some effects. Otherwise, apply a different set of effects. This is used to implement e.g. threshold."
    ];
    Mill mill = 32
        [(comment.comment) = "Mill some number of cards for a target player."];
    Modes modal = 33 [
      (comment.comment) =
          "Offer the controller of this effect a choice between several modes, then apply the chosen effects."
    ];
    ModifyTarget modify_target = 34 [
      (comment.comment) =
          "Apply a modifier to a specific target from a list of valid targets."
    ];
    MultiplyTokens multiply_tokens = 35 [
      (comment.comment) =
          "Multiply the number of tokens created. This is only applied as a replacement effect."
    ];
    PayCostThen pay_cost_then = 36 [
      (comment.comment) =
          "Ask the controller of this effect to pay some cost, then trigger some effects if they paid the cost."
    ];
    Rebound rebound = 37 [
      (comment.comment) =
          "Implement the Rebound keyword. You don't need to specify this, the keyword will work."
    ];
    ReturnFromGraveyardToBattlefield return_from_graveyard_to_battlefield = 38
        [(comment.comment) =
             "Return a card from the graveyard to the battlefield."];
    ReturnFromGraveyardToHand return_from_graveyard_to_hand = 39 [
      (comment.comment) =
          "Return a card from the graveyard to the hand. TODO: This should probably be merged with ReturnTargetToHand."
    ];
    ReturnFromGraveyardToLibrary return_from_graveyard_to_library = 40 [
      (comment.comment) =
          "Return a card from the graveyard to the library. TODO: This should probably be merged with TargetToTopOfLibrary."
    ];
    ReturnSelfToHand return_self_to_hand = 41
        [(comment.comment) =
             "Return the card associated with this effect to hand."];
    ReturnTargetToHand return_target_to_hand = 42
        [(comment.comment) = "Return target card to the hand."];
    ReturnTransformed return_transformed = 43 [
      (comment.comment) =
          "Return a card from exile or graveyard to the battlefield transformed."
    ];
    RevealEachTopOfLibrary reveal_each_top_of_library = 44 [
      (comment.comment) =
          "Reveal the top card of each player's library, then apply some effects depending on the revealed cards."
    ];
    Scry scry = 45 [(comment.comment) = "Scry some number of cards."];
    SelfExplores self_explores = 46
        [(comment.comment) = "The card with the effect explores."];
    TapTarget tap_target = 47 [
      (comment.comment) =
          "Tap a target permanent. This automatically narrows the list of targets to targets on the battlefield."
    ];
    TapThis tap_this = 48
        [(comment.comment) = "Tap the card associated with this effect."];
    TargetControllerGainsTokens target_controller_gains_tokens = 49 [
      (comment.comment) =
          "The controller of something targetted by another effect gets a token."
    ];
    TargetCopiesPermanent target_copies_permanent = 50 [
      (comment.comment) =
          "A target permanent on battlefield, narrowed by restrictions, becomes a copy of another permanent spell or on the battlefield, narrowed by restrictions."
    ];
    TargetCreatureExplores target_creature_explores = 51 [
      (comment.comment) =
          "The targetted creature explores. This automatically narrows the list of valid targets to creatures on the battlefield."
    ];
    TargetGainsCounters target_gains_counters = 52 [
      (comment.comment) =
          "Place some number of counters on a target, narrowed by a list of restrictions."
    ];
    TargetToTopOfLibrary target_to_top_of_library = 53
        [(comment.comment) =
             "Return target to the top of its owner's library."];
    Transform transform = 54 [
      (comment.comment) =
          "Transform in place on the battlefield. This will preserve equipment and auras attached to the transformed card."
    ];
    TutorLibrary tutor_library = 55 [
      (comment.comment) =
          "Search the library for cards matching some set of restrictions and allow the player to move it to a location."
    ];
    UntapThis untap_this = 56
        [(comment.comment) = "Untap the card associated with this effect."];
    UntapTarget untap_target = 57 [
      (comment.comment) =
          "Untap a target permanent. THis automatically narrows the list of targets to targets on the battlefield."
    ];
  }

  string oracle_text = 58;
}

message ActivatedAbility {
  cost.AbilityCost cost = 1;
  repeated Effect effects = 2;
  string oracle_text = 3;
  bool sorcery_speed = 4;
  bool craft = 5;
}

message ApplyThen {
  repeated Effect apply = 1;
  repeated Effect then = 2;
}

message ApplyThenIfWas {
  message Then {
    repeated targets.Restriction if_was = 1;
    repeated Effect apply = 2;
  }

  repeated Effect apply = 3;
  Then then = 4;
}

message BattleCry {}

message BattlefieldModifier {
  ModifyBattlefield modifier = 1;
  Duration duration = 2;
  repeated targets.Restriction restrictions = 3;
  bool apply_to_self = 4;
}

message CantAttackThisTurn {
  repeated targets.Restriction restrictions = 1;
}

message Cascade {}

message ChooseCast {
  repeated targets.Restriction restrictions = 1;
}

message ControllerDiscards {
  uint32 count = 1;
  repeated targets.Restriction unless = 2;
}

message ControllerDrawsCards {
  message Fixed {
    int32 count = 1;
  }

  oneof count {
    Fixed fixed = 2;
    NumberOfPermanentsMatching number_of_permanents_matching = 3;
  }
}

message ControllerLosesLife {
  uint32 count = 1;
  repeated targets.Restriction unless = 2;
}

message CopyOfAnyCreatureNonTargeting {}

message CopySpellOrAbility {
  repeated targets.Restriction restrictions = 1;
}

message Count {
  message Fixed {
    uint32 count = 1;
  }
  message Dynamic {
    message X {}
    message LeftBattlefieldThisTurn {
      repeated targets.Restriction restrictions = 1;
    }

    oneof dynamic {
      LeftBattlefieldThisTurn left_battlefield_this_turn = 2;
      X x = 3;
    }
  }

  oneof count {
    Fixed fixed = 4;
    Dynamic dynamic = 5;
  }
}

message CounterSpellOrAbility {
  repeated targets.Restriction restrictions = 1;
}

message CounterSpellUnlessPay {
  message Fixed {
    int32 count = 1;
  }

  oneof cost {
    Fixed fixed = 2;
  }

  repeated targets.Restriction restrictions = 3;
}

message CreateToken {
  message Creature {
    string name = 1;
    types.Typeline typeline = 2;
    repeated color.Color colors = 3;
    optional DynamicPowerToughness dynamic_power_toughness = 4;
    int32 power = 5;
    int32 toughness = 6;
    map<int32, uint32> keywords = 7;
  }
  message Map {}

  oneof token {
    Creature creature = 1;
    Map map = 2;
  }
}

message CreateTokenCopy {
  repeated ModifyBattlefield modifiers = 1;
}

message Cycling {
  map<int32, empty.Empty> types = 1;
  map<int32, empty.Empty> subtypes = 2;
}

message DealDamage {
  uint32 quantity = 1;
  repeated targets.Restriction restrictions = 2;
}

message Destination {
  message Hand {}
  message TopOfLibrary {}
  message BottomOfLibrary {}
  message Graveyard {}
  message Battlefield {
    bool enters_tapped = 1;
  }
  oneof destination {
    Hand hand = 2;
    TopOfLibrary top_of_library = 3;
    BottomOfLibrary bottom_of_library = 4;
    Graveyard graveyard = 5;
    Battlefield battlefield = 6;
  }
}

message DestroyEach {
  repeated targets.Restriction restrictions = 1;
}

message DestroyTarget {
  repeated targets.Restriction restrictions = 1;
}

message Discover {
  message X {
    cost.XIs x_is = 1;
  }
  message Fixed {
    uint32 count = 1;
  }
  oneof count {
    X x = 2;
    Fixed fixed = 3;
  }
}

enum Duration {
  PERMANENTLY = 0;
  UNTIL_END_OF_TURN = 1;
  UNTIL_SOURCE_LEAVES_BATTLEFIELD = 2;
  UNTIL_TARGET_LEAVES_BATTLEFIELD = 3;
  UNTIL_UNTAPPED = 4;
}

message DynamicPowerToughness {
  oneof source {
    NumberOfCountersOnThis number_of_counters_on_this = 1;
    NumberOfPermanentsMatching number_of_permanents_matching = 2;
  }

  message NumberOfCountersOnThis {
    counters.Counter counter = 1;
  }
}

message Equip {
  repeated ModifyBattlefield modifiers = 1;
}

message ExamineTopCards {
  message Dest {
    Destination destination = 1;
    uint32 count = 2;
  }

  uint32 count = 3;
  repeated Dest destinations = 4;
}

message ExileTarget {
  Duration duration = 1;
  repeated targets.Restriction restrictions = 2;
}

message ExileTargetCreatureManifestTopOfLibrary {}

message ExileTargetGraveyard {}

message ExtraLandsPerTurn {
  uint32 count = 1;
}

message ForEachManaOfSource {
  mana.ManaSource source = 1;
  Effect effect = 2;
}

message ForEachPlayerChooseThen {
  repeated targets.Restriction restrictions = 1;
  bool is_optional = 2;
  repeated Effect effects = 3;
}

message GainCounters {
  Count count = 1;
  counters.Counter counter = 2;
}

message GainLife {
  uint32 count = 1;
}

message GainMana {
  message Specific {
    repeated mana.Mana gain = 1;
  }
  message GainMana {
    repeated mana.Mana gains = 1;
  }
  message Choice {
    repeated GainMana choices = 1;
  }
  oneof gain {
    Specific specific = 2;
    Choice choice = 3;
  }
}

message GainManaAbility {
  cost.AbilityCost cost = 1;
  GainMana gain_mana = 2;
  mana.ManaSource mana_source = 3;
  mana.ManaRestriction mana_restriction = 4;
  string oracle_text = 5;
  repeated Effect additional_effects = 6;
}

message IfThenElse {
  repeated targets.Restriction if = 1;
  repeated Effect then = 2;
  repeated Effect else = 3;
}

message Mill {
  uint32 count = 1;
  repeated targets.Restriction restrictions = 2;
}

message ModifyBattlefield {
  optional int32 base_power = 1;
  optional int32 base_toughness = 2;
  optional DynamicPowerToughness add_dynamic_power_toughness = 3;
  map<int32, empty.Empty> add_types = 4;
  map<int32, empty.Empty> add_subtypes = 5;
  map<int32, empty.Empty> remove_types = 6;
  map<int32, empty.Empty> remove_subtypes = 7;
  repeated color.Color add_colors = 8;
  optional int32 add_power = 9;
  optional int32 add_toughness = 10;
  optional ActivatedAbility add_ability = 11;
  optional GainManaAbility mana_ability = 12;
  repeated StaticAbility add_static_abilities = 13;
  bool remove_all_creature_types = 14;
  bool remove_all_types = 15;
  bool remove_all_subtypes = 16;
  bool remove_all_colors = 17;
  bool remove_all_abilities = 18;
  bool unblockable = 19;
  bool entire_battlefield = 20;
  bool global = 21;
  map<int32, uint32> add_keywords = 22;
  map<int32, uint32> remove_keywords = 23;
}

message MultiplyTokens {
  uint32 multiplier = 1;
}

message NumberOfPermanentsMatching {
  repeated targets.Restriction restrictions = 1;
}

message PayCostThen {
  cost.AbilityCost cost = 1;
  repeated Effect effects = 2;
}

message Rebound {}

message ReturnFromGraveyardToBattlefield {
  uint32 count = 1;
  repeated targets.Restriction restrictions = 2;
  optional cost.XIs x_is = 3;
  bool enters_tapped = 4;
}

message ReturnFromGraveyardToHand {
  uint32 count = 1;
  repeated targets.Restriction restrictions = 2;
}

message ReturnFromGraveyardToLibrary {
  uint32 count = 1;
  repeated targets.Restriction restrictions = 2;
}

message ReturnSelfToHand {}

message ReturnTargetToHand {
  repeated targets.Restriction restrictions = 1;
}

message RevealEachTopOfLibrary {
  message ForEach {
    message IfNone {
      repeated Effect effects = 1;
    }
    repeated targets.Restriction restrictions = 2;
    repeated Effect effects = 3;
    IfNone if_none = 4;
  }
  ForEach for_each = 5;
}

message Scry {
  uint32 count = 1;
}

message SelfExplores {}

message StaticAbility {
  message AddKeywordsIf {
    map<int32, uint32> keywords = 1;
    repeated targets.Restriction restrictions = 2;
  }
  message AllAbilitiesOfExiledWith {
    repeated cost.AbilityRestriction activation_restrictions = 1;
  }
  message CantCastIfAttacked {}
  message ForceEtbTapped {
    repeated targets.Restriction restrictions = 1;
  }
  message GreenCannotBeCountered {
    repeated targets.Restriction restrictions = 1;
  }
  message PreventAttacks {}
  message PreventBlocks {}
  message PreventAbilityActivation {}
  message UntapEachUntapStep {}

  oneof ability {
    AddKeywordsIf add_keywords_if = 1;
    AllAbilitiesOfExiledWith all_abilities_of_exiled_with = 2;
    BattlefieldModifier battlefield_modifier = 3;
    CantCastIfAttacked cant_cast_if_attacked = 4;
    ExtraLandsPerTurn extra_lands_per_turn = 5;
    ForceEtbTapped force_etb_tapped = 6;
    GreenCannotBeCountered green_cannot_be_countered = 7;
    PreventAttacks prevent_attacks = 8;
    PreventBlocks prevent_blocks = 9;
    PreventAbilityActivation prevent_ability_activation = 10;
    UntapEachUntapStep untap_each_untap_step = 11;
  }
}

message TapTarget {
  repeated targets.Restriction restrictions = 1;
}

message TapThis {}

message TargetControllerGainsTokens {
  CreateToken create_token = 1;
}

message TargetCopiesPermanent {
  repeated targets.Restriction target_restrictions = 1;
  repeated targets.Restriction copy_restrictions = 2;
}

message TargetCreatureExplores {}

message TargetGainsCounters {
  Count count = 1;
  counters.Counter counter = 2;
  repeated targets.Restriction restrictions = 3;
  bool is_optional = 4;
}

message TargetToTopOfLibrary {
  uint32 under_cards = 1;
  repeated targets.Restriction restrictions = 2;
}

message Transform {}

message TutorLibrary {
  repeated targets.Restriction restrictions = 1;
  Destination destination = 2;
  bool reveal = 3;
}

message ReturnTransformed {
  bool enters_tapped = 1;
}

message UntapTarget {
  repeated targets.Restriction restrictions = 1;
}

message UntapThis {}

message Mode {
  repeated Effect effects = 1;
}

message Modes {
  repeated Mode modes = 1;
}

message ModifyTarget {
  ModifyBattlefield modifier = 1;
  Duration duration = 2;
  repeated targets.Restriction restrictions = 3;
}

message ReplacementEffect {
  enum Replacing {
    DRAW = 0;
    ETB = 1;
    TOKEN_CREATION = 2;
  }

  Replacing replacing = 3;
  repeated targets.Restriction restrictions = 4;
  repeated Effect effects = 5;
}